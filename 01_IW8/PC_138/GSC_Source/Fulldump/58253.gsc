// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

_id_128E3()
{
    self.playershowskippromptcinematic = anglestoforward( self.angles );
    self.initial_up = anglestoup( self.angles );
    self.playerskipkioskuse = anglestoright( self.angles );

    if ( !isdefined( level.targets_thinking ) )
        level.targets_thinking = 0;

    level.targets_thinking++;
    self.down_angles = self.angles;
    self.parts = getentarray( self.script_linkname, "script_linkto" );
    self.parts = scripts\engine\utility::array_remove( self.parts, self );

    foreach ( var_1 in self.parts )
    {
        switch ( var_1.script_noteworthy )
        {
            case "target_plate":
                self.plate = var_1;
                break;
            case "target_plate_dest":
                self.plate = var_1;
                self.traversal_disabled_by_management = var_1;
                break;
            case "target_arm":
                self.arm = var_1;
                break;
            case "target_base":
                self.base = var_1;
                break;
            case "target_wheels":
                self.wheels = var_1;
                break;
            case "target_aim_assist":
                self.aim_assist = var_1;
                break;
            case "target_collision":
                self.collision = var_1;
                break;
            case "target_collision_down":
                self.collision_down = var_1;
                break;
            case "target_collision_up":
                self.collision_up = var_1;
                break;
            default:
                break;
        }

        var_1.target = "null";
        var_1.targetname = "null";
    }

    self.plate linkto( self );
    self.arm linkto( self );

    if ( isdefined( self.wheels ) )
        self.wheels linkto( self.base );

    if ( isdefined( self.base ) )
    {
        if ( isdefined( self.collision ) )
            self.collision linkto( self.base );

        if ( isdefined( self.collision_down ) )
            self.collision_down linkto( self.base );

        if ( isdefined( self.collision_up ) )
            self.collision_up linkto( self.base );
    }

    self.state_up = 0;
    self.flipping = 0;

    if ( issubstr( self.script_noteworthy, "civilian" ) )
    {
        self.is_civilian = 1;
        level.civilian_targets[level.civilian_targets.size] = self;
    }
    else
    {
        self.is_civilian = 0;
        level.enemy_targets[level.enemy_targets.size] = self;
    }

    thread _id_128DC();

    if ( isdefined( self.traversal_disabled_by_management ) )
        thread _id_128DA();

    self.activated = 0;
    thread _id_128E2();

    if ( issubstr( self.script_noteworthy, "moving" ) )
        thread _id_128BF();

    if ( isdefined( level._id_128E4 ) )
        self [[ level._id_128E4 ]]();

    if ( isdefined( level._id_128E5 ) )
        self thread [[ level._id_128E5 ]]();

    level.targets_thinking--;
}

gettargetarray()
{
    var_0 = [ "standard_target", "standard_target_180", "standard_target_civilian", "lean_target", "lean_target_civilian", "moving_target", "moving_target_civilian" ];
    var_1 = [];

    for ( var_2 = 0; var_2 < var_0.size; var_2++ )
    {
        var_3[var_2] = scripts\engine\utility::getstructarray( var_0[var_2], "script_noteworthy" );

        foreach ( var_5 in var_3[var_2] )
        {
            var_6 = spawn( "script_origin", var_5.origin );
            var_6.angles = var_5.angles;
            var_6.script_gameobjectname = var_5.script_gameobjectname;
            var_6.script_linkname = var_5.script_linkname;
            var_6.script_noteworthy = var_5.script_noteworthy;
            var_6.target = var_5.target;
            var_6.targetname = var_5.targetname;
        }
    }

    for ( var_2 = 0; var_2 < var_0.size; var_2++ )
        var_1[var_2] = getentarray( var_0[var_2], "script_noteworthy" );

    return scripts\engine\utility::array_combine_multiple( var_1 );
}

_id_128DC()
{
    var_0 = undefined;

    if ( isdefined( self.traversal_disabled_by_management ) )
    {
        var_1 = "trial_sfx_target_report_clay_smash";
        var_0 = level.play_found_first_lead_vo;
    }
    else
        var_1 = "trial_sfx_target_report_metal_light";

    for (;;)
    {
        self.activated = 0;

        while ( self.state_up == 0 )
            waitframe();

        self.plate waittill( "damage", var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11 );
        self.plate playsound( var_1 );

        if ( self.is_civilian == 1 )
            level.player thread _debug_rooftop_raid_exfil::_id_128B5( self, 0, 1, 0 );
        else
            level.player thread _debug_rooftop_raid_exfil::_id_128B5( self, 1, 0, 0 );

        self.activated = 1;

        if ( var_6 == "MOD_MELEE" )
            level.player notify( "fake_weapon_fired" );

        if ( self.is_civilian && isdefined( level._id_128DB ) )
            self [[ level._id_128DB ]]();
        else if ( isdefined( level._id_128DD ) )
            self [[ level._id_128DD ]]();

        if ( isdefined( level._id_128E0 ) && self.plate tagexists( "tag_head" ) && distance( self.plate gettagorigin( "tag_head" ), var_5 ) <= 5 )
            self [[ level._id_128E0 ]]();

        if ( isdefined( var_0 ) )
            playfx( var_0, var_5 );

        if ( isdefined( self.traversal_disabled_by_management ) )
        {
            self.traversal_disabled_by_management hide();
            wait( randomfloatrange( 0.7, 1 ) );
        }

        thread _id_128DE( "down" );
        level waittill( "course_ended" );

        if ( isdefined( self.traversal_disabled_by_management ) )
        {
            _debug_rooftop_raid_exfil::trial_ui_waittill_retry();
            self.traversal_disabled_by_management show();
        }
    }
}

_id_128DE( var_0 )
{
    if ( var_0 == "up" )
    {
        if ( isdefined( self.script_delay ) )
            wait( self.script_delay );

        self.plate setcandamage( 1 );

        if ( isdefined( self.aim_assist ) )
            self.aim_assist enableaimassist();

        if ( isdefined( self.collision_up ) )
            self.collision_up solid();

        if ( isdefined( self.collision_down ) )
            self.collision_up notsolid();

        if ( self.state_up == 1 )
            return;

        self.state_up = 1;
        var_1 = 1;
    }
    else
    {
        self.plate setcandamage( 0 );

        if ( isdefined( self.aim_assist ) )
            self.aim_assist disableaimassist();

        if ( isdefined( self.collision_up ) )
            self.collision_up notsolid();

        if ( isdefined( self.collision_down ) )
            self.collision_up solid();

        if ( self.state_up == 0 )
            return;

        self.state_up = 0;
        var_1 = -1;
    }

    var_2 = undefined;
    var_3 = undefined;

    switch ( self.script_noteworthy )
    {
        case "standard_target_civilian":
        case "moving_target_civilian":
        case "moving_target":
        case "standard_target":
            var_3 = 90;
            var_2 = 0.2;
            break;
        case "lean_target_civilian":
        case "lean_target":
            var_3 = 30;
            var_2 = 0.15;
            break;
        case "standard_target_180":
            var_3 = 180;
            var_2 = 0.4;
            break;
        default:
            var_3 = 90;
            var_2 = 0.2;
            break;
    }

    self.flipping = 1;

    if ( issubstr( self.script_noteworthy, "moving" ) )
        waitframe();

    if ( var_0 == "up" )
        self playsoundonmovingent( "trial_sfx_target_flipup" );

    if ( self.playerskipkioskuse[2] != 0 )
        self rotateyaw( -1 * self.playerskipkioskuse[2] * var_3 * var_1, var_2 );
    else
        self rotatepitch( var_3 * var_1, var_2 );

    wait( var_2 );

    if ( var_0 == "down" )
    {
        waitframe();
        self playsoundonmovingent( "trial_sfx_target_flipdown" );
        self.angles = self.down_angles;
    }

    self.flipping = 0;
}

_id_128BF()
{
    self.mover = scripts\engine\utility::getclosest( self.origin, level.course_movers, 32 );

    if ( !isdefined( self.mover ) )
        return;

    self.mover_ends = scripts\engine\utility::getstructarray( self.mover.targetname, "target" );
    self.mover_ends = sortbydistance( self.mover_ends, self.mover.origin );
    var_0 = self.mover.origin - self.origin;
    self.mover.origin = self.mover.origin + var_0;
    self.mover_ends[0].origin = self.mover_ends[0].origin + var_0;
    self.mover_ends[1].origin = self.mover_ends[1].origin + var_0;
    self.moveforward = 1;
    self.moving = 0;

    if ( isdefined( self.script_speed ) )
        self.move_speed = self.script_speed;
    else
        self.move_speed = 32;

    level waittill( "player_spawned" );
    thread _id_128BE();

    for (;;)
    {
        if ( self.moving && ( 90 > distance( level.player.origin, self.origin ) || !self.state_up ) )
        {
            self notify( "stop_moving" );
            self.moving = 0;
            self.dummy delete();
            self.plate playsound( "trial_sfx_target_move_stop" );
            self.dummy thread scripts\engine\utility::stop_loop_sound_on_entity( "trial_sfx_target_move_loop" );
        }
        else if ( self.flipping == 0 && self.moving == 0 && 90 < distance( level.player.origin, self.origin ) && self.state_up == 1 )
            thread _id_128BD();

        waitframe();
    }
}

_id_128BD()
{
    self endon( "stop_moving" );
    self.moving = 1;
    self.dummy = spawn( "script_origin", self.origin );
    childthread _id_128DF();
    self.dummy thread scripts\engine\utility::play_loop_sound_on_entity( "trial_sfx_target_move_loop" );
    self.plate playsound( "trial_sfx_target_move_start" );

    for (;;)
    {
        var_0 = self.mover_ends[self.moveforward];
        var_1 = distance( self.dummy.origin, var_0.origin );
        var_2 = var_1 / self.move_speed;
        var_3 = 0.5;
        var_3 = clamp( var_3, 0, var_2 / 2 );
        self.dummy moveto( var_0.origin, var_2, var_3, var_3 );
        wait( var_2 );
        self.moveforward = !self.moveforward;
    }
}

_id_128BE()
{
    for (;;)
    {
        level waittill( "trial_results_screen_opened" );
        waitframe();
        self.origin = self.mover.origin;
        self.base.origin = self.mover.origin;
        self.moveforward = 1;
    }
}

_id_128DF()
{
    for (;;)
    {
        self.origin = self.dummy.origin;
        self.base.origin = self.dummy.origin;
        waitframe();
    }
}

_id_128DA()
{
    self.arm setcandamage( 1 );

    for (;;)
    {
        self.arm waittill( "damage", var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 );

        if ( var_4 == "MOD_EXPLOSIVE" || var_4 == "MOD_GRENADE" || var_4 == "MOD_GRENADE_SPLASH" && istrue( self.state_up ) )
            self.plate dodamage( 1, self.plate.origin );
    }
}

_id_128E2()
{
    waitframe();

    if ( isdefined( self.targetname ) )
        var_0 = getentarray( self.targetname, "target" );
    else
        var_0 = [];

    for (;;)
    {
        var_1 = 1;

        foreach ( var_3 in var_0 )
        {
            if ( var_3.activated == 0 )
                var_1 = 0;
        }

        if ( var_1 == 1 )
        {
            _id_128DE( "up" );
            level waittill( "course_ended" );
        }

        waitframe();
    }
}

_id_128EC()
{
    var_0 = getentarray( "end_checkpoint", "script_noteworthy" );

    for (;;)
    {
        self.activated = 0;
        _debug_rooftop_raid_exfil::waittill_player_isdefined();

        if ( isdefined( self.script_noteworthy ) )
        {
            if ( self.script_noteworthy != "start" )
                level waittill( "course_started" );
        }
        else
            level waittill( "course_started" );

        while ( level.player istouching( self ) )
            waitframe();

        if ( isdefined( self.script_noteworthy ) && self.script_noteworthy == "end" )
        {
            for (;;)
            {
                self waittill( "trigger" );

                if ( battle_tracks_updatebattletracks( var_0 ) )
                    break;
            }
        }
        else
            self waittill( "trigger" );

        self.activated = 1;
        level notify( "trigger_activated" );

        if ( isdefined( level._id_128EB ) )
            self [[ level._id_128EB ]]();

        level waittill( "course_ended" );
    }
}

battle_tracks_updatebattletracks( var_0 )
{
    foreach ( var_2 in var_0 )
    {
        if ( !var_2.activated )
            return 0;
    }

    return 1;
}
