// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init()
{
    thread player_is_at_buy_station();
}

player_is_at_buy_station()
{
    level._effect["sentry_overheat_mp"] = loadfx( "vfx/core/mp/killstreaks/vfx_sg_overheat_smoke" );
    level._id_128CF = [];

    while ( !isdefined( level.struct_class_names ) )
        waitframe();

    var_0 = scripts\engine\utility::getstructarray( "trial_enemy_sentry_turret", "targetname" );

    while ( !isdefined( level.sentrysettings ) )
        waitframe();

    level.sentrysettings["trial_sentry_turret"] = level.sentrysettings["sentry_turret"];
    level.sentrysettings["trial_sentry_turret"].spinuptime = level.sentrysettings["trial_sentry_turret"].spinuptime * 2;
    level.sentrysettings["trial_sentry_turret"].health = 150;

    foreach ( var_2 in var_0 )
    {
        waitframe();
        level._id_128CF[level._id_128CF.size] = _id_11F1C( var_2 );
    }

    level._id_11D96 = 1;
}

_id_11F1C( var_0, var_1 )
{
    var_2 = "trial_sentry_turret";
    var_3 = level.sentrysettings[var_2];
    var_4 = spawnturret( "misc_turret", var_0.origin, level.sentrysettings[var_2].weaponinfo );
    var_4.team = scripts\mp\utility\game::getotherteam( level.trial["team"] )[0];

    if ( !isdefined( var_0.angles ) )
        var_0.angles = ( 0, 0, 0 );

    var_4.angles = var_0.angles;
    var_4.health = var_3.maxhealth;
    var_4.maxhealth = var_3.maxhealth;
    var_4.sentrytype = var_2;
    var_4.momentum = 0;
    var_4.heatlevel = 0;
    var_4.overheated = 0;
    var_4.cooldownwaittime = 2;
    var_4.turrettype = "sentry_turret";

    if ( !isdefined( var_1 ) )
        var_1 = "weapon_wm_mg_sentry_turret";

    var_4 setmodel( var_1 );
    var_4 setturretteam( var_4.team );
    var_4 makeunusable();
    var_4 setnodeploy( 1 );
    var_4 setdefaultdroppitch( 0 );
    var_4 setautorotationdelay( 0.2 );
    var_4 maketurretinoperable();
    var_4 setleftarc( 80 );
    var_4 setrightarc( 80 );
    var_4 setbottomarc( 50 );
    var_4 settoparc( 60 );
    var_4 setconvergencetime( 0.6, "pitch" );
    var_4 setconvergencetime( 0.6, "yaw" );
    var_4 setconvergenceheightpercent( 0.65 );
    var_4 setdefaultdroppitch( -89.0 );
    var_4 setturretmodechangewait( 1 );
    var_4 solid();
    var_0.turret = var_4;
    wait 1;
    var_4 setmode( "auto_nonai" );
    var_4 thread gas_trigger_think();
    var_4 thread sentry_attacktargets();
    var_4 thread sentry_handledeath();
    var_4 thread sentry_handledamage();
    var_4 thread scripts\cp_mp\killstreaks\sentry_gun::sentry_beepsounds();
    var_4.escape_if_player_is_in_hangar = spawn( "script_model", var_4.origin );
    var_4.escape_if_player_is_in_hangar setmodel( "weapon_vm_mg_sentry_turret_invis_base" );
    var_4.escape_if_player_is_in_hangar dontinterpolate();
    var_4.escape_if_player_is_in_hangar.angles = var_4.angles;
    var_4.escape_if_player_is_in_hangar.origin = var_4.origin;
    var_4.escape_if_player_is_in_hangar linkto( var_4, "tag_aim_pivot" );
    var_5 = "icon_minimap_sentry";
    var_4.minimapid = var_4.escape_if_player_is_in_hangar scripts\mp\objidpoolmanager::createobjective( var_5, var_4.team, undefined, 1, 1 );

    if ( isdefined( level._id_128EF ) )
        var_4 thread [[ level._id_128EF ]]();

    return var_4;
}

ignorefallback()
{
    self endon( "death" );
    self endon( "kill_turret" );
    level endon( "game_ended" );
    var_0 = self.origin;
    var_1 = 0.05;
    var_2 = int( var_1 * 20 );

    for (;;)
        wait( var_1 );
}

gas_trigger_think()
{
    self endon( "death" );
    self endon( "kill_turret" );
    level endon( "game_ended" );
    self setcandamage( 1 );

    for (;;)
    {
        self waittill( "damage", var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11, var_12, var_13, var_14 );

        if ( !isdefined( var_1 ) || !isplayer( var_1 ) && ( !isdefined( var_1.owner ) || !isplayer( var_1.owner ) ) )
            continue;

        if ( isdefined( var_9.basename ) )
        {
            if ( issubstr( var_9.basename, "emp_drone" ) )
            {

            }
        }

        var_15 = isdefined( var_1 ) && isplayer( var_1 );
        var_16 = isdefined( var_1.owner ) && isplayer( var_1.owner );
        var_17 = isdefined( var_1.classname ) && var_1.classname == "script_vehicle" && isdefined( var_1.owner ) && isplayer( var_1.owner );
        var_18 = var_17 && var_4 == "MOD_CRUSH";
    }
}

sentry_attacktargets()
{
    self endon( "death" );
    level endon( "game_ended" );
    self.momentum = 0;
    self.heatlevel = 0;
    self.overheated = 0;
    thread sentry_heatmonitor();

    for (;;)
    {
        scripts\engine\utility::waittill_either( "turretstatechange", "cooled" );

        if ( self isfiringturret() )
        {
            self laseron();
            thread sentry_burstfirestart();
            continue;
        }

        self laseroff();
        sentry_spindown();
        thread sentry_burstfirestop();
    }
}

sentry_targetlocksound()
{
    self endon( "death" );
    level.player playsound( "sentry_gun_beep" );
    wait 0.1;
    level.player playsound( "sentry_gun_beep" );
    wait 0.1;
    level.player playsound( "sentry_gun_beep" );
}

sentry_spinup()
{
    thread sentry_targetlocksound();

    while ( self.momentum < level.sentrysettings[self.sentrytype].spinuptime )
    {
        self.momentum = self.momentum + 0.1;
        wait 0.1;
    }
}

sentry_spindown()
{
    self.momentum = 0;
}

sentry_burstfirestart()
{
    self endon( "death" );
    self endon( "stop_shooting" );
    level endon( "game_ended" );
    sentry_spinup();
    var_0 = 4 * weaponfiretime( level.sentrysettings[self.sentrytype].weaponinfo );
    var_1 = level.sentrysettings[self.sentrytype].burstmin;
    var_2 = level.sentrysettings[self.sentrytype].burstmax;
    var_3 = level.sentrysettings[self.sentrytype].pausemin;
    var_4 = level.sentrysettings[self.sentrytype].pausemax;

    for (;;)
    {
        var_5 = randomintrange( var_1, var_2 + 1 );

        for ( var_6 = 0; var_6 < var_5 && !self.overheated; var_6++ )
        {
            self shootturret();
            self notify( "bullet_fired" );
            self.heatlevel = self.heatlevel + var_0;
            wait( var_0 );
        }

        wait( randomfloatrange( var_3, var_4 ) );
    }
}

sentry_burstfirestop()
{
    self notify( "stop_shooting" );
}

sentry_heatmonitor()
{
    if ( istrue( self._id_1209C ) )
        return;

    self endon( "death" );
    var_0 = weaponfiretime( level.sentrysettings[self.sentrytype].weaponinfo );
    var_1 = 0;
    var_2 = 0;
    var_3 = level.sentrysettings[self.sentrytype].overheattime;
    var_4 = level.sentrysettings[self.sentrytype].cooldowntime;

    for (;;)
    {
        if ( self.heatlevel != var_1 )
            wait( var_0 );
        else
            self.heatlevel = max( 0, self.heatlevel - 0.05 );

        if ( self.heatlevel > var_3 )
        {
            self.overheated = 1;
            thread playheatfx();

            while ( self.heatlevel )
            {
                self.heatlevel = max( 0, self.heatlevel - var_4 );
                wait 0.1;
            }

            self.overheated = 0;
            self notify( "not_overheated" );
        }

        var_1 = self.heatlevel;
        wait 0.05;
    }
}

playheatfx()
{
    self endon( "death" );
    self endon( "not_overheated" );
    level endon( "game_ended" );
    self notify( "playing_heat_fx" );
    self endon( "playing_heat_fx" );

    for (;;)
    {
        playfxontag( scripts\engine\utility::getfx( "sentry_overheat_mp" ), self, "tag_flash" );
        wait( level.sentrysettings[self.sentrytype].fxtime );
    }
}

sentry_beepsounds()
{
    self endon( "death" );
    level endon( "game_ended" );

    for (;;)
    {
        wait 3.0;

        if ( !isdefined( self.carriedby ) )
            self playsound( "sentry_gun_beep" );
    }
}

sentry_handledeath()
{
    self waittill( "death" );

    if ( !isdefined( self ) )
        return;

    self setmode( "sentry_offline" );
    self setscriptablepartstate( "explode", "violent" );

    if ( isdefined( level._id_128EE ) )
    {
        if ( isdefined( self.br_latejoininfilready ) && gettime() < self.br_latejoininfilready + 4000 )
            self [[ level._id_128EE ]]();
    }

    if ( isdefined( self ) )
        thread sentry_deleteturret();
}

sentry_handledamage()
{
    for (;;)
    {
        self waittill( "damage", var_0, var_1 );

        if ( var_1 == level.player )
        {
            var_1 scripts\mp\damagefeedback::updatedamagefeedback( "hitequip" );
            self.br_latejoininfilready = gettime();
        }
    }
}

sentry_deleteturret()
{
    self notify( "sentry_delete_turret" );
    self endon( "sentry_delete_turret" );

    if ( isdefined( self.escape_if_player_is_in_hangar ) )
        self.escape_if_player_is_in_hangar delete();

    wait 1.5;
    playfxontag( scripts\engine\utility::getfx( "sentry_explode_mp" ), self, "tag_aim" );
    playfxontag( scripts\engine\utility::getfx( "sentry_smoke_mp" ), self, "tag_aim" );
    self playsound( "sentry_explode_smoke" );
    wait 0.1;
    self notify( "deleting" );

    if ( isdefined( self ) )
        self delete();
}
