// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

bomber_init( var_0, var_1, var_2 )
{
    scripts\asm\shared\utility::setbasearchetype( "_encstr_8EF60E63FBE3D70440A312175B98CF6B" );

    if ( self isscriptable() )
        thread initscriptable();
}

initscriptable()
{
    self endon( "_encstr_AD75063D571AE108" );
    scripts\engine\utility::flag_wait( "_encstr_ABEC127358A564FBBB9F4A4CA5637F6A23D08A2B" );
    self setscriptablepartstate( "_encstr_91D412889743FAA31A374E7409E9D3052411270B", "_encstr_930B07BB1B6B3854FF", 0 );
}

shouldexplode( var_0, var_1, var_2, var_3 )
{
    return istrue( self.explode );
}

playanim_explode( var_0, var_1, var_2 )
{
    self endon( var_1 + "_encstr_A3DB0AF5332DDCD237D0AC8C" );
    thread scripts\asm\shared\utility::waitfordooropen( var_0, var_1, 1 );
    var_3 = scripts\asm\asm::asm_getanim( var_0, var_1 );
    var_4 = scripts\asm\asm::asm_getxanim( var_1, var_3 );
    self aisetanim( var_1, var_3 );
    var_5 = getanimlength( var_4 );
    var_6 = getnotetracktimes( var_4, "_encstr_860808CB78E2984063BA" )[0];

    if ( isdefined( var_6 ) )
        var_5 = var_5 * var_6;

    wait( var_5 );

    if ( isdefined( level.suicide_bomber_explode_func ) )
        self thread [[ level.suicide_bomber_explode_func ]]( self );

    self.nocorpse = 1;
    thread bomber_detonation();
}

playanim_bomberdeath( var_0, var_1, var_2 )
{
    if ( !istrue( self.hasexploded ) && !istrue( self.skipdetonation ) )
    {
        if ( !istrue( self.instantexplode ) )
        {
            thread scripts\asm\soldier\death::playdeathanim( var_0, var_1 );

            if ( !isagent( self ) )
                wait 1.2;

            if ( !isagent( self ) || isalive( self ) )
                stopfxontag( scripts\engine\utility::getfx( "_encstr_B6261D375D5AD8961956D74C7B6B3156E4BE8D1B2D365BB29C7D99D8B09B1A" ), self, "_encstr_A1190B94FAAB9396DC47EB89A8" );
        }

        if ( !istrue( self.diequietly ) )
        {
            self.nocorpse = 1;
            bomber_detonation();
        }
        else
            self.nocorpse = undefined;
    }
}

bomber_detonation()
{
    self.hasexploded = 1;
    waitframe();

    if ( !isdefined( self ) )
        return;

    if ( objective_mlgicon() )
    {
        if ( isdefined( self ) && isdefined( self.grenadeweapon ) && istrue( self.bomberusegrenade ) )
            var_0 = self magicgrenade( self.origin + ( 0, 0, 60 ), self.origin, 0.0, 0 );
        else
        {
            playfx( level.g_effect["_encstr_8BF513F2D8AB36D38EEC3132E8F1E73DC1180AAA10"], self.origin );
            playfx( level.g_effect["_encstr_B4031FEC333CEB6ED5A5D8D28CCA7D98BDD64CACE4AFB3D2137D56E1078DBD4656"], self.origin );
            thread createextractionlocation();
            self playsound( "_encstr_A2D710230D27839761101B53117B721AC59E" );
        }
    }
    else
    {
        playfx( level.g_effect["_encstr_B1DF20B3CC3CBE37ABB48DD232CAAF26DBDA2659E4FA737BF59196B9B695B64C954E"], self.origin );
        thread createextractionlocation();
        self playsound( "_encstr_A2D710230D27839761101B53117B721AC59E" );
    }

    playrumbleonposition( "_encstr_85D30FAF13F238C0494D4F4AC323DD0BE9", self.origin );

    if ( scripts\engine\utility::is_equal( level.gametype, "_encstr_839E0CBFD1801B5DB0D34C932998" ) )
        earthquake( 0.8, 0.6, self.origin, 350 );
    else
        earthquake( 1.0, 0.6, self.origin, 1500 );

    self notify( "_encstr_AC8F0AC94174F85AFA901D30" );
    waitframe();

    if ( !isdefined( self ) )
        return;

    if ( !isagent( self ) )
        self delete();
    else
        self kill();
}

kidnapperdebug( var_0, var_1 )
{
    wait( var_0 );
    playfx( level.g_effect["_encstr_B1DF20B3CC3CBE37ABB48DD232CAAF26DBDA2659E4FA737BF59196B9B695B64C954E"], var_1 );
}

createextractionlocation()
{
    if ( scripts\engine\utility::is_equal( level.gametype, "_encstr_8B6B0B26FA20C3E85FFAA84F0B" ) )
        radiusdamage( self.origin + ( 0, 0, 60 ), 500, 250, 75 );
    else if ( scripts\engine\utility::is_equal( level.gametype, "_encstr_839E0CBFD1801B5DB0D34C932998" ) )
        radiusdamage( self.origin + ( 0, 0, 60 ), 300, 250, 75, self );
    else
        self radiusdamage( self.origin + ( 0, 0, 60 ), 500, 250, 75, self );
}

bomber_finishpainhead( var_0, var_1, var_2 )
{
    scripts\asm\soldier\pain::cleanuppainanim( var_0, var_1, var_2 );
}

playanim_bombermoveloop( var_0, var_1, var_2 )
{
    self endon( var_1 + "_encstr_A3DB0AF5332DDCD237D0AC8C" );
    thread scripts\asm\shared\utility::waitfordooropen( var_0, var_1, 1 );
    var_3 = scripts\asm\asm::asm_lookupanimfromalias( var_1, "_encstr_AFAB063620A0C612" );
    self aisetanim( var_1, var_3 );
    thread blendspacerndm( var_1 );

    for (;;)
        scripts\asm\asm::asm_donotetracks( var_0, var_1 );
}

blendspacerndm( var_0 )
{
    self endon( "_encstr_AD75063D571AE108" );
    self endon( var_0 + "_encstr_A3DB0AF5332DDCD237D0AC8C" );

    for (;;)
    {
        var_1 = randomfloatrange( -1, 1 );
        self setcivilianfocus( var_1 );
        wait( randomfloatrange( 0.25, 2 ) );
    }
}

bomber_shouldraisearm( var_0, var_1, var_2, var_3 )
{
    return istrue( self.bomberraisearm );
}
