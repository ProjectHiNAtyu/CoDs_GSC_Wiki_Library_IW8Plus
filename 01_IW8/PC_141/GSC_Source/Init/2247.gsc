// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

_isalive()
{
    return isalive( self ) && !isdefined( self.fauxdead ) && !istrue( self.delayedspawnedplayernotify );
}

setusingremote( var_0 )
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "setUsingRemote" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "setUsingRemote" ) ]]( var_0 );
}

clearusingremote( var_0 )
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "clearUsingRemote" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "clearUsingRemote" ) ]]( var_0 );
}

isusingremote()
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "isUsingRemote" ) )
        return [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "isUsingRemote" ) ]]();

    return 0;
}

isinvehicle( var_0 )
{
    if ( isdefined( self.vehicle ) && isdefined( self.vehicle.vehiclename ) )
        return 1;

    if ( istrue( var_0 ) )
    {
        if ( isdefined( self._id_13003 ) && isdefined( self._id_13003.vehiclename ) )
            return 1;
    }

    return 0;
}

getvehicle()
{
    if ( !isinvehicle() )
        return undefined;

    return self.vehicle;
}

_freezecontrols( var_0, var_1, var_2 )
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "freezeControls" ) )
        return [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "freezeControls" ) ]]( var_0, var_1, var_2 );
}

add_client_back_to_mask_after_delay()
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "freezeControlsDebug" ) )
        return [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "freezeControlsDebug" ) ]]();
}

_freezelookcontrols( var_0, var_1 )
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "freezeLookControls" ) )
        return [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "freezeLookControls" ) ]]( var_0, var_1 );
}

getplayersuperfaction( var_0 )
{
    var_1 = 0;

    if ( isdefined( var_0.operatorcustomization ) )
        var_1 = var_0.operatorcustomization.superfaction;

    return var_1;
}

setthermalvision( var_0, var_1, var_2 )
{
    if ( istrue( var_0 ) )
    {
        self enablephysicaldepthoffieldscripting();
        self setphysicaldepthoffield( var_1, var_2, 20, 20 );
        self thermalvisionon();
    }
    else
    {
        self disablephysicaldepthoffieldscripting();
        self thermalvisionoff();
    }
}

watchthermalinputchange()
{
    self notify( "watch_thermal_input_change" );
    self endon( "watch_thermal_input_change" );

    for (;;)
    {
        var_0 = getthermalswitchplayercommand();
        self notifyonplayercommand( "switch_thermal_mode", var_0 );
        var_1 = scripts\engine\utility::_id_1313C( "input_type_changed", "thermal_handling_ended" );
        self notifyonplayercommandremove( "switch_thermal_mode", var_0 );

        if ( !isdefined( var_1 ) || var_1 == "thermal_handling_ended" )
            break;
    }
}

stopwatchingthermalinputchange()
{
    self notify( "thermal_handling_ended" );
}

getthermalswitchplayercommand()
{
    if ( scripts\engine\utility::is_player_gamepad_enabled() )
        return "+stance";

    return "nightvision";
}

enabledemeanorsafe()
{
    if ( !isdefined( self.demeanorsafeenabled ) )
        self.demeanorsafeenabled = 0;

    self.demeanorsafeenabled++;

    if ( self.demeanorsafeenabled == 1 )
        forcedemeanorsafe( 1 );
}

disabledemeanorsafe()
{
    self.demeanorsafeenabled--;

    if ( self.demeanorsafeenabled == 0 )
    {
        self.demeanorsafeenabled = undefined;
        forcedemeanorsafe( 0 );
    }
}

forcedemeanorsafe( var_0 )
{
    if ( var_0 && self getdemeanorviewmodel() != "safe" )
        thread forcedemeanorsafeinteral( var_0 );
    else if ( !var_0 && self getdemeanorviewmodel() == "safe" )
        thread forcedemeanorsafeinteral( var_0 );
}

forcedemeanorsafeinteral( var_0 )
{
    self endon( "death_or_disconnect" );
    self notify( "forceDemeanorSafeInteral" );
    self endon( "forceDemeanorSafeInteral" );
    var_1 = self issprinting();

    if ( !istrue( self.demeanorsprintdisable ) )
    {
        scripts\common\utility::allow_sprint( 0 );
        self.demeanorsprintdisable = 1;
    }

    if ( var_1 )
        wait 0.5;

    if ( var_0 )
        self setdemeanorviewmodel( "safe", "iw8_ges_demeanor_safe" );
    else
        self setdemeanorviewmodel( "normal" );

    wait 0.5;

    if ( istrue( self.demeanorsprintdisable ) )
    {
        scripts\common\utility::allow_sprint( 1 );
        self.demeanorsprintdisable = undefined;
    }
}

cleardemeanorsafe()
{
    self.demeanorsafeenabled = undefined;
    self.demeanorsprintdisable = undefined;
}

playersareenemies( var_0, var_1 )
{
    if ( !isdefined( var_0 ) || !isdefined( var_1 ) )
        return undefined;

    if ( !isdefined( var_0.team ) || !isdefined( var_1.team ) )
        return undefined;

    if ( level.teambased )
        return var_0.team != var_1.team;
    else
        return var_0 != var_1;
}

vehicle_registration_func()
{
    return self isbnetkr15player() || scripts\common\utility::iswegameplatform();
}

progression_speed()
{
    level.watch_for_attack = [];
}

animscripted_single_arrive_at()
{
    if ( !self isdismembermentenabledforplayer() )
        level.watch_for_attack[self getxuid()] = self;
}

_id_11C80()
{
    level.watch_for_attack[self getxuid()] = undefined;
}

mix()
{
    return level.watch_for_attack;
}

addplayeraslootleader()
{
    if ( !isdefined( self.wait_and_destroy ) )
        self.wait_and_destroy = 0;

    if ( self.wait_and_destroy == 0 )
        self playerhide();

    self.wait_and_destroy++;
}

addplundercarrycredit()
{
    if ( self.wait_and_destroy == 1 )
        self playershow();

    self.wait_and_destroy--;

    if ( self.wait_and_destroy == 0 )
        self.wait_and_destroy = undefined;
}

wait_between_stations()
{
    self.wait_and_destroy = undefined;

    if ( !isdefined( level.waittillmatch_loop ) )
        level.waittillmatch_loop = getdvarint( "scr_playerShowOnReset", 0 );

    if ( level.waittillmatch_loop )
        self playershow();
}
