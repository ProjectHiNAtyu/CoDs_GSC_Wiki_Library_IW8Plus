// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init( var_0, var_1 )
{
    var_2 = scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "getGameType" ) && [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "getGameType" ) ]]() == "br";

    if ( var_2 )
        var_3 = monitor( var_1 );
    else
        var_3 = 180;

    if ( !isdefined( level.light_tank_monitordriverturretprojectilefire ) )
    {
        if ( var_2 )
            level.light_tank_monitordriverturretprojectilefire = getdvarfloat( "scr_br_gasMask_resist", 0 );
        else
            level.light_tank_monitordriverturretprojectilefire = 0.2;
    }

    self.gasmaskhealth = var_3;
    self.light_tank_stopwatchingmissileinputchange = var_3;
    self.light_target_init = var_1;
    var_4 = 2;

    if ( regroup_at_truck( var_1 ) )
        var_4 = 3;

    if ( isdefined( var_0 ) )
        self.gasmaskhealth = var_0;

    if ( var_2 )
        level.light_tank_removegunnerdamagemod = self.gasmaskhealth / 6;

    level.light_tank_stopwatchingmissileinputchange = var_3;
    self setclientomnvar( "ui_head_equip_class", var_4 );
    self setclientomnvar( "ui_gasmask_damage", self.gasmaskhealth / var_3 );
}

regroup_at_truck( var_0 )
{
    return isdefined( var_0 ) && var_0 == "brloot_equip_gasmask_durable";
}

monitor( var_0 )
{
    if ( regroup_at_truck( var_0 ) )
        return level.br_pickups.counts["brloot_equip_gasmask_durable"];
    else
        return level.br_pickups.counts["brloot_equip_gasmask"];
}

processdamage( var_0 )
{
    var_1 = scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "getGameType" ) && [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "getGameType" ) ]]() == "br";
    var_2 = self.gasmaskhealth / self.light_tank_stopwatchingmissileinputchange;
    self.gasmaskhealth = self.gasmaskhealth - var_0;
    self.gasmaskhealth = max( 0, self.gasmaskhealth );

    if ( var_1 )
        var_3 = ( self.gasmaskhealth + 1 ) / self.light_tank_stopwatchingmissileinputchange;
    else
        var_3 = self.gasmaskhealth / self.light_tank_stopwatchingmissileinputchange;

    self setclientomnvar( "ui_gasmask_damage", var_3 );

    if ( self.gasmaskhealth <= 0 )
    {
        if ( var_1 && scripts\cp_mp\utility\script_utility::issharedfuncdefined( "gasmask", "breakGasMaskBR" ) )
            self [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "gasmask", "breakGasMaskBR" ) ]]();
        else
            breakgasmask();
    }
    else if ( var_1 )
    {
        var_4 = floor( var_2 * 6 + 0.5 );
        var_5 = floor( var_3 * 6 + 0.5 );

        if ( var_4 > var_5 )
            self playsoundtoplayer( "br_gas_mask_crack_plr", self );
    }

    if ( !isdefined( self.gasdamagebuffer ) )
        self.gasdamagebuffer = 0;

    self.gasdamagebuffer = self.gasdamagebuffer + var_0 * level.light_tank_monitordriverturretprojectilefire;
    var_6 = floor( self.gasdamagebuffer );

    if ( var_6 >= 1 )
    {
        self dodamage( var_6, self.origin, self, undefined, "MOD_TRIGGER_HURT" );
        self.gasdamagebuffer = self.gasdamagebuffer - var_6;
    }
}

grouptorewards( var_0, var_1 )
{
    var_2 = scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "getGameType" ) && [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "getGameType" ) ]]() == "br";

    if ( !var_2 )
        return 0;

    if ( !isdefined( self.light_tank_stopwatchingmissileinputchange ) )
        self.light_tank_stopwatchingmissileinputchange = monitor( self.light_target_init );

    var_3 = var_0 / self.light_tank_stopwatchingmissileinputchange;
    var_4 = var_1 / self.light_tank_stopwatchingmissileinputchange;
    var_5 = floor( var_3 * 6 + 0.5 );
    var_6 = floor( var_4 * 6 + 0.5 );
    return var_5 != var_6;
}

equipgasmask()
{
    self endon( "death_or_disconnect" );
    self playsoundtoplayer( "br_gas_mask_on_plr", self );
    var_0 = getcompleteweaponname( "none" );
    var_1 = self getcurrentweapon();

    if ( !isnullweapon( var_1, var_0 ) )
        self forceplaygestureviewmodel( "ges_visor_down" );

    self.gasmaskswapinprogress = 1;
    wait 0.338;
    self.gasmaskswapinprogress = 0;
    self.gasmaskequipped = 1;
    scripts\cp_mp\killstreaks\white_phosphorus::enableloopingcoughaudiosupression();

    if ( istrue( self.operatorcustomization.playanim_aibegindismountturret ) )
        self attach( "hat_gasmask" );

    createoverlay();

    if ( isdefined( self.operatorcustomization.gender ) && self.operatorcustomization.gender == "female" )
        self _meth_87A8( "gasmask_female" );
    else
        self _meth_87A8( "gasmask_male" );
}

removegasmask()
{
    self endon( "death_or_disconnect" );

    if ( !istrue( self.gasmaskequipped ) )
        return;

    self playsoundtoplayer( "br_gas_mask_off_plr", self );
    var_0 = getcompleteweaponname( "none" );
    var_1 = self getcurrentweapon();

    if ( !isnullweapon( var_1, var_0 ) )
        self forceplaygestureviewmodel( "ges_visor_up" );

    self.gasmaskswapinprogress = 1;
    wait 0.521;
    self.gasmaskswapinprogress = 0;
    self.gasmaskequipped = 0;
    scripts\cp_mp\killstreaks\white_phosphorus::disableloopingcoughaudiosupression();

    if ( istrue( self.operatorcustomization.playanim_aibegindismountturret ) )
        self detach( "hat_gasmask" );

    destroyoverlay();

    if ( isdefined( self.operatorcustomization.gender ) && self.operatorcustomization.gender == "female" )
        self _meth_87A8( "female" );
    else
        self _meth_87A8( "" );
}

breakgasmask()
{
    if ( !istrue( self.gasmaskequipped ) )
        return;

    self.gasmaskequipped = 0;
    self playsoundtoplayer( "br_gas_mask_crack_plr", self );

    if ( istrue( self.operatorcustomization.playanim_aibegindismountturret ) )
        self detach( "hat_gasmask" );

    destroyoverlay();

    if ( isdefined( self.operatorcustomization.gender ) && self.operatorcustomization.gender == "female" )
        self _meth_87A8( "female" );
    else
        self _meth_87A8( "" );

    self playsoundtoplayer( "br_gas_mask_depleted_plr", self );
    self setclientomnvar( "ui_head_equip_class", 0 );
    self setclientomnvar( "ui_gasmask_damage", 0 );
}

createoverlay( var_0, var_1 )
{
    self.gasmaskoverlay = newclienthudelem( self );
    self.gasmaskoverlay.x = 0;
    self.gasmaskoverlay.y = 0;
    self.gasmaskoverlay.alignx = "left";
    self.gasmaskoverlay.aligny = "top";
    self.gasmaskoverlay.horzalign = "fullscreen";
    self.gasmaskoverlay.vertalign = "fullscreen";
    self.gasmaskoverlay setshader( "gasmask_overlay_delta2", 640, 480 );
    self.gasmaskoverlay.sort = -10;
    self.gasmaskoverlay.archived = 1;

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "getGameType" ) )
    {
        if ( [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "getGameType" ) ]]() == "br" )
        {
            self.gasmaskoverlay.alpha = 0.0;

            if ( isdefined( var_0 ) )
            {
                if ( isdefined( var_1 ) )
                    wait( var_1 );

                if ( isdefined( self.gasmaskoverlay ) )
                    self.gasmaskoverlay fadeovertime( var_0 );
            }
        }
    }

    if ( isdefined( self.gasmaskoverlay ) )
    {
        self.gasmaskoverlay.alpha = 1.0;
        self.gasmaskoverlay.lowresbackground = 1;
    }
}

_id_120F7()
{
    if ( isdefined( self.gasmaskoverlay ) )
        self.gasmaskoverlay setshader( "gasmask_overlay_delta2_broken", 640, 480 );
}

isinlaststand( var_0 )
{
    self.gasmaskoverlay.alpha = 1.0;
    self.gasmaskoverlay fadeovertime( var_0 );
    self.gasmaskoverlay.alpha = 0.0;
}

destroyoverlay( var_0, var_1 )
{
    level endon( "game_ended" );
    self endon( "death_or_disconnect" );

    if ( !isdefined( self.gasmaskoverlay ) )
        return;

    if ( isdefined( var_0 ) )
    {
        if ( isdefined( var_1 ) )
            wait( var_1 );

        if ( isdefined( self.gasmaskoverlay ) )
        {
            isinlaststand( var_0 );
            wait( var_0 );
        }
    }

    if ( isdefined( self.gasmaskoverlay ) )
    {
        self.gasmaskoverlay destroy();
        self.gasmaskoverlay = undefined;
    }
}

hasgasmask( var_0 )
{
    return isdefined( var_0.gasmaskhealth );
}
